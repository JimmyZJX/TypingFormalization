\section{Introduction}

Modern functional programming languages, such as Haskell or OCaml,
use sophisticated forms of type inference. The type systems of these languages are
descendents of Hindley-Milner~\cite{}, which was revolutionary at the
time in allowing type-inference to proceed without any type
annotation. The traditional Hindley-Milner type system supports
top-level \emph{implicit (parametric) polymorphism}. With implicit
polymorphism, type arguments of polymorphic functions are
automatically instantiated. Thus the Hindley-Milner type system 
strikes a great balance between expressive power and usability. 

As functional languages evolved the need for more expressive
power has motivated language designers to look beyond Hindley-Milner.
In particular one popular direction has been to allow 
\emph{higher-ranked polymorphism} where polymorphic types can
occur anywhere in a type signature.  
An important challenge is that full type inference for higher-ranked
polymorphism is know to be undecidable~\cite{}. Therefore some type
annotations are necessary to guide type inference. In response to this 
challenge several decidable type systems requiring some annotations 
have been proposed~\cite{}. Two closely related type systems that 
support \emph{predicative} higher-ranked type inference were proposed 
by Peyton Jones et al.~\cite{} and Dunfield and
Krishnaswami (henceforth denoted as DK). 
These type systems are
popular among language designer and their ideas have been adopted by
several modern functional languages, including Haskell and PureScript.
In those type systems
type annotations are required for polymorphic arguments of functions.
but other type annotations can be omitted. A canonical example is:
\bruno{the following text needs to be changed, since it is basically
  as in ITP.}
\begin{verbatim}
hpoly = (\f :: forall a. a -> a) -> (f 1, f 'c')
\end{verbatim}
The function \verb|hpoly| cannot be
type-checked in Hindley-Milner.  The type of \verb|hpoly| is 
\verb|(forall a. a -> a) -> (Int, Char)|. The single universal quantifier
does not appear at the top-level. Instead it is used to quantify a
type variable \verb|a| used in the first argument of the
function.
Notably \verb|hpoly| requires a type annotation for the first
argument (\verb|forall a. a -> a|). 
Despite these additional annotations,
the type-inference algorithm employed by GHC Haskell~\cite{jones2007practical} preserves 
many of the desirable properties of Hindley-Milner. 

Despite the importance of type inference in practice and also in
academic research, there is little work in mechanically formalizing
such advanced forms of type inference in theorem provers. This is at
odds with a current trend in programming language research. In
particular both the POPLMark challenge~\cite{} and CompCert ~\cite{}
have significantly promoted the use of theorem provers to model
variaous aspects of programming languages. Indeed today there are
routinely papers in top conferences that use theorem provers to
mechanically formalize various aspects of programming languages,
including: \emph{dynamic and static semantics} and their
correctness properties~\cite{}, \emph{compiler correctness}~\cite{},
\emph{correctness of optimizations}~\cite{} or even certain forms of
\emph{abstract interpretation}. Mechanical formalizations have
numerous advantages~\cite{read to make sure I do not miss any!}. 

This paper presents the first full mechanical formalization of the metatheory for
higher-ranked polymorphic type inference. The system that we formalize
is the bidirectional type system by Dunfield and
Krishnaswami (DK). The DK type system has two variants (a declarative
and an algorithmic one) that have been been \emph{manually} proved to be
\emph{sound}, \emph{complete} and \emph{decidable}. 

We present 
a mechanical formalization in the Abella theorem prover 
for DK's declarative type system using a different algorithm. We use a
new algorithm for a few different reasons. Firstly, our new algorithm
employs \emph{worklist judgements}, which allow precise capture of the
scope of vairables and simplify the formalization of scoping in a
theorem prover. Secondly, while DK's original formalization comes with very
well-written manual proofs, there are several details missing,
which complicate the task of writing a formla proof. 
Perhaps more importantly, some proofs/lemmas are wrong and it is
not clear how to replace these by other valid proofs/lemmas. 
\bruno{others} 

Despite the use of a different algorithm we prove the
same results by DK, although with significantly different proofs and
proof techniques.  

The calculus and its metatheory
have been fully formalized in the Abella theorem prover\cite{AbellaDesc}. % Add at least one ref to make compile work normally

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf A full mechanical formalization of type inference with
    higher-ranked types:}

\item {\bf A new algorithm for DK:}

\item {\bf Worlists with inference judgments:}

\item {\bf Abella formalization:} The calculus and its metatheory
have been fully formalized in the Abella theorem prover\cite{AbellaDesc}.

\end{itemize}