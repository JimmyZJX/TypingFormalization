\section{Algorithmic System}

This section introduces a novel algorithmic system that implements 
DK's declarative specification. The algorithmic system comes with
several novelties.\bruno{fill in/summarize novelties. I think
  novelties include: precise scoping control; CPS-style; dealing with
  inference judgements.}

\subsection{Syntax and Well-Formedness}

Figure~\ref{fig:alg:syntax} shows the syntax---with accompanying well-formedness judgement---used by the algorithm.

\begin{figure}
\begin{gather*}
\begin{aligned}
% \text{Type variables}\qquad&a, b\\
\text{Existential variables}\qquad&\al, \bt
\\[2mm]
%\text{Types}\qquad&A', B', C' &::=&\quad 1 \mid a \mid \forall x. A' \mid A'\to B'\\
% \text{Mono-types}\qquad&\tau &::=&\quad 1 \mid a \mid \tau_1\to \tau_2\\
%\text{Context}\qquad&\Psi &::=&\quad \nil \mid \Psi, a \mid \Psi, x:A' \color{red} \\[2mm]
% \text{Declarative Judgements}\qquad&\jo &::=&\quad \nil \mid \P\vdash A' \le B' \jc \jo\\
% &&&\quad \mid \P\vdash e\Leftarrow A' \jc \jo \mid \P\vdash e\To A' \jc \jo \mid \P\vdash A' \bullet e\TTo C' \jc \jo\\
% \noalign{\jimmy{\text{What do the markers do: $\G \vdash,a \vdash,b\vdash \j_1;\j_2;\j_3$ means $\G,a,b\vdash \j_1 \land \G,a\vdash \j_1,\j_2 \land \G\vdash \j_3$}}} \\[2mm]
\text{Algorithmic types}\qquad&A, B, C &::=& \quad \ldots \mid \al % \quad 1 \mid a \mid \al \mid \forall a. A \mid A\to B
\\[2mm]
% \text{Terms}\qquad&e&::=&\quad x \mid () \mid \lam{e} \mid e_1~e_2 \mid (e:A)
% \\[2mm]
\text{Algorithmic judgement chain}\qquad&\jg &::=&\quad A \le B \mid e\Lto A \mid e\To_{a} \jg \mid \appInfAlg{A}{e}
\\[2mm]
\text{Algorithmic worklist}\qquad&\Gm &::=&\quad \nil \mid \Gm, a \mid \Gm, \al \mid \Gm, x: A \mid \Gm \Vdash \jg%\\
% \text{Declarative worklist}\qquad&\Om &::=&\quad \nil \mid \Om, a \mid \Om, x: A \mid \Om \Vdash \jg
\end{aligned}
\end{gather*}

\framebox{$\Gm\vdash\jg$} Well-formed algorithmic judgment
\begin{gather*}
\inferrule*[right=$\mathtt{wf{\le}}$]
{\Gm\vdash A \\ \Gm\vdash B}
{\Gm\vdash A\le B}
\qquad
\inferrule*[right=$\mathtt{wf{\Lto}}$]
{\Gm\vdash e \\ \Gm\vdash A}
{\Gm\vdash e \Lto A}
\\
\inferrule*[right=$\mathtt{wf{\To}}$]
{\Gm\vdash e \\ \Gm, a\vdash \jg}
{\Gm\vdash e \To_a \jg}
\qquad
\inferrule*[right=$\mathtt{wf{\TTo}}$]
{\Gm\vdash A \\ \Gm, a\vdash \jg \\ \Gm\vdash e}
{\Gm\vdash \appInfAlg{A}{e}}
\end{gather*}

\framebox{$\text{wf }\Gm$} Well-formed algorithmic worklist
\begin{gather*}
\inferrule*[right=$\mathtt{wf\nil}$]
{~}{\text{wf }\nil}
\qquad
\inferrule*[right=$\mathtt{wf_a}$]
{\text{wf }\Gm}
{\text{wf }\Gm, a}
\qquad
\inferrule*[right=$\mathtt{wf_{\al}}$]
{\text{wf }\Gm}
{\text{wf }\Gm, \al}
\qquad
\inferrule*[right=$\mathtt{wf_{of}}$]
{\text{wf }\Gm \\ \Gm\vdash A}
{\text{wf }\Gm, x:A}
\qquad
\inferrule*[right=$\mathtt{wf_{\jg}}$]
{\text{wf }\Gm \\ \Gm\vdash\jg}
{\text{wf }\Gm \Vdash\jg}
\end{gather*}
\caption{Extended Syntax and Well-Formedness for the Algorithmic System}\label{fig:alg:syntax}
\end{figure}

\paragraph{Existential Variables} 
The algorithmic system inherits the syntax of terms and types from 
the declartive system. It only introduces one additional feature.
In order to find unknown types $\tau$ in the declarative system, the
algorithmic system extends the declarative types $A$ with \emph{existential variables} $\al, \bt$.
They behave like unification variables,
but their scope is restricted by their position in the
worklist\bruno{be careful to ensure that the reader knows about
  worklist at this point},
rather than being global.
Any existential variable $\al$ should only be solved to
a type that is well-formed with respect to the worklist to which $\al$ has been added.
The point is that the mono-type $\tau$ represented by the corresponding existential variable
is always well-formed under the corresponding declarative context.
In other words, the position of $\al$'s reflects the well-formedness restriction of $\tau$'s.

%% A \le B \mid e\Lto A \mid e\To_{a} \jg \mid \appInfAlg{A}{e}

\paragraph{Judgment Chains} 
Judgment chains, or judgments for short, $\jg$ are the core components of our algorithmic
type-checking. There are four kinds
of these judgments in our system: subtyping ($A \le B$), checking ($e\Lto
A$), inference ($e\To_{a} \jg$) and
application inference ($\appInfAlg{A}{e}$).  Subtyping and checking are relatively simple,
since their result is only success or failure. However both inference and
application inference return a type that is used in further computation. We use a
continuation-passing-style encoding to accomplish this. For example, the judgment
chain $e \To_a (a \le B)$ contains two judgments: first we want to
infer the type of the expression $e$, and then check if that type is a
subtype of $B$. The \emph{unknown} type of $e$ is represented by a
type variable $a$, which is used as a placeholder in the second judgement to denote the 
type of $e$.

\paragraph{Worklist Judgments} Our algorithm has a non-standard form.
We combine traditional contexts and judgment(s) into a single object, the \emph{worklist} $\Gm$.
The worklist is an \emph{ordered} collection of both variable bindings and judgments. The order captures the scope:
only the objects that come after a variable's binding in the worklist can refer to it.
For example, $[a,x:a,x \Lto a]$ is a valid worklist, but $[\textcolor{red}{x} \Lto a, x:\textcolor{red}{a},a]$ is not (the red symbols refer to out-of-scope variables).

\paragraph{Hole Notation}
We use the syntax $\Gm[\Gm_M]$ to denote the worklist $\Gm_L,\Gm_M,\Gm_R$,
where $\Gm$ is the worklist $\Gm_L,\bullet,\Gm_R$ with a hole ($\bullet$).
Hole notations with the same name implicitly share the same structure $\Gm_L$ and $\Gm_R$.
A multi-hole notation splits the worklist into more parts.
For example, $\Gm[\al][\bt]$ means $\Gm_1,\al,\Gm_2,\bt,\Gm_3$.

\subsection{Algorithmic System}

\newcounter{algRuleCounter}
\newcommand \algrule {\stepcounter{algRuleCounter}\rrule{\arabic{algRuleCounter}}}

% TODO rules too long
\begin{figure}[htp]
\hfill \framebox{$\Gm\rto \Gm'$} \hfill $\Gm$ reduces to $\Gm'$.
%\jimmy{Whenever there is a change on judgment count, marker should be properly added/removed. Decidability: all valid judgment chain should be reduced to nil.}
\begin{gather*}
\begin{aligned}
\Gm, a &\algrule \Gm \qquad
\Gm, \al \algrule \Gm \qquad
\Gm, x:A \algrule \Gm
\\[2mm]
\Gm \Vdash 1\le 1 &\algrule \Gm\\
\Gm \Vdash a\le a &\algrule \Gm\\
\Gm \Vdash \al\le \al &\algrule \Gm\\
\Gm \Vdash A_1\to A_2 \le B_1\to B_2 &\algrule \Gm \Vdash A_2 \le B_2 \Vdash B_1\le A_1\\
\Gm \Vdash \forall a. A\le B &\algrule \Gm,\al \Vdash [\al/a]A\le B \quad\text{when } B \neq \all B' \quad\text{\jimmy{No more exvar leaks}}\\
\Gm \Vdash A\le \forall b. B &\algrule \Gm,b \Vdash A\le B \quad\text{\jimmy{No more typevar leaks}}
\\[2mm]
%\\
%\text{Let } \color{red}\Gm[\al \toto B // G_M] &:= \Gm_L, G_M, [B/\al]\Gm_R, \text{ when } \Gm[\al] = \Gm_L,\al,\Gm_R \ (G_M\text{ defaults to }\nil)\\
\Gm[\al] \Vdash \al \le A\to B &\algrule [\al[1]\to\al[2]/\al] (\Gm[\al[1], \al[2]] \Vdash \al[1]\to \al[2] \le A \to B)\\
 &\qquad \text{when }\al\notin FV(A)\cup FV(B)\\
\Gm[\al] \Vdash A\to B \le \al &\algrule [\al[1]\to \al[2]/\al] (\Gm[\al[1], \al[2]] \Vdash A \to B \le \al[1]\to \al[2])\\
 &\qquad \text{when }\al\notin FV(A)\cup FV(B)
 \\[2mm]
\Gm[\al][\bt] \Vdash \al \le \bt &\algrule [\al/\bt](\Gm[\al][])\\
\Gm[\al][\bt] \Vdash \bt \le \al &\algrule [\al/\bt](\Gm[\al][])\\
\Gm[a][\bt] \Vdash a \le \bt &\algrule [a/\bt](\Gm[a][])\\
\Gm[a][\bt] \Vdash \bt \le a &\algrule [a/\bt](\Gm[a][])\\
\Gm[\bt] \Vdash 1 \le \bt &\algrule [1/\bt](\Gm[])\\
\Gm[\bt] \Vdash \bt \le 1 &\algrule [1/\bt](\Gm[])
\\[2mm]
\Gm \Vdash e \Lto B &\algrule \Gm \Vdash e\To_a a\le B \quad
    \text{when } e \neq \lam e' \text{ and } B \neq \all B'\\
% \Gm \Vdash () \Lto 1 &\algrule \Gm\\
\Gm \Vdash e\Lto \forall a. A &\algrule \Gm,a \Vdash e\Lto A\\
\Gm \Vdash \lambda x. e \Lto A\to B &\algrule \Gm, x:A  \Vdash e \Lto B\\
\Gm[\al] \Vdash \lambda x. e \Lto \al &\algrule [\al[1]\to \al[2] / \al](\Gm[\al[1],\al[2]], x:\al[1] \Vdash e \Lto \al[2]) \quad\text{\jimmy{Additional}}
\\[2mm]
\Gm \Vdash x\To_a \jg &\algrule \Gm \Vdash [A/a] \jg \quad \text{when } (x:A)\in \Gm\\
\Gm \Vdash (e:A)\To_a \jg &\algrule \Gm \Vdash [A/a]\jg \Vdash e \Lto A\\
\Gm \Vdash ()\To_a \jg &\algrule \Gm \Vdash [1/a]\jg \qquad\jimmy{\downarrow\text{Precise control on exvars}}\\
\Gm \Vdash \lambda x. e \To_a \jg &\algrule
    \Gm,\al,\bt \Vdash [\al\to\bt/a]\jg, x:\al \Vdash e\Lto \bt \quad\jimmy{\text{differs}}\\
\Gm \Vdash e_1\ e_2 \To_a \jg &\algrule \Gm \Vdash e_1\To_b (\appInfAlg{b}{e_2})
\\[2mm]
\Gm \Vdash \appInfAlg{\forall a. A}{e} &\algrule \Gm,\al \Vdash \appInfAlg{[\al/a]A}{e}\\
\Gm \Vdash \appInfAlg{A\to C}{e} &\algrule \Gm \Vdash [C/a]\jg \Vdash e \Lto A\\
\Gm[\al] \Vdash \appInfAlg{\al}{e} &\algrule
    [\al[1]\to\al[2]/\al](\Gm[\al[1], \al[2]] \Vdash \appInfAlg{\al[1]\to\al[2]}{e})
%	[\al[1]\to\al[2]/\al](\Gm[\al[1], \al[2]] \Vdash [\al[2]/a]\jg \Vdash e\Lto \al[1])\\
% &\color{magenta} \makebox[0pt]{\qquad or} \phantom{{}\rrule{}{}}
\end{aligned}
\end{gather*}
\caption{Algorithmic Typing}\label{fig:alg}
\end{figure}

The algorithmic typing reduction rules, defined in Figure~\ref{fig:alg}, have
the form $\Gm \rto \Gm'$.
% The worklists $\Gm, \Gm'$ contain both variable declarations and judgments.
The reduction process treats the worklist as a stack.  In every step it pops
the first judgment from the worklist for processing and possibly pushes new
judgments onto the worklist.  The syntax $\Gm\redto \Gm'$ denotes multiple
reduction steps. If $\Gm\redto\nil$, we say that $\Gm$ reduces successfully;
this corresponds to a successful type checking.

Let us explain the rulres in more detail:
Rules 1-3 pop a variable declaration; this garbage collects variables that are
out of scope for the remaining judgements.
All other rules concern a judgement at the front of the worklist. Logically we
can discern 6 group of rules.

\begin{description}
\item[1. Declarative Rules]
We have six subtyping rules (Rules 4-9) that are similar to their
declarative counterparts. For instance, Rule 7 consumes a subtyping
judgment and pushes two back to the worklist.  Rule 8 differs from
declarative Rule ${\le}{\forall}L$ by introducing an existential
variable $\al$ instead of guessing the monotype $\tau$ for
instantiation. Each existential variable is later solved to a
monotype $\tau$ with the same context, so the final solution $\tau$ of
$\al$ should be well-formed under context $\Gm$.

\paragraph{Worklist Variable Scoping}
Rules 8 and 9 involve variable declarations and demonstrate how our
worklist treats variable scopings. Rule 8 introduces an existential
variable $\al$ that is only visible to the judgment $[\al/a]A \le B$.
Reduction continues until all the subtyping judgments after $\al$
are satisfied.  Finally we can safely remove $\al$ since no occurrence
of $\al$ could have leaked into the left part of the worklist.  Moreover,
the algorithm garbage-collects the $\al$
variable at the perfect time: it leaves the environment immediately
after being unreferenced.
\jimmy{An example on subtyping: $\nil\vdash (1\to 1)\to 1 \le (\forall a. a\to a) \to 1$
TODO derivation and explanation}
\bruno{Perhaps this is better illustrated with a simple example?}
\tom{Yes, it would be good to show one or more
example derivations to illustrate the key points.}

The design of our judgment chain is closely related to the property of
the judgments
\jimmy{requires further clarification}
\bruno{What property? Not very clear}.
Subtyping and checking do not return anything, so variables cannot
leak anyway, as applied to Rules 8 and 9.
\bruno{Is the discussion that follows in the right place? We just jump
  to
  rule 26. Perhaps we can wait until we talk about inference to
  discuss those issues?}
However, inference and application inference may return a type that contains new variables.
Take Rule 26 as an example, if it simply returns $\al \to \bt$,
passes that to the next judgment and continues the type-checking process,
variables $\al$ and $\bt$ in the next judgment are out of scope
and will break the well-formedness of the worklist.
By making use of the continuation-passing-style judgement chain,
inner judgments always shares context with its parent judgment,
therefore we preserve well-formedness during reduction.

\item[2. Existential decomposition]
Rules 10 and 11 are algorithmic versions of Rule $\mathtt{{\le}{\to}}$; they
both partially instantiate $\al$ to function types.
The domain $\al[1]$ and range $\al[2]$ of the new function type are not determined:
they are fresh existential variables with the same scope as $\al$.
We remove replace $\al$ in the worklist with  $\al[1], \al[2]$.
To propagate the instantiation to the rest of the worklist and maintain well-formedness,
every reference to $\al$ is replaced by $\al[1] \to \al[2]$.
The \emph{occurs-check} condition prevents divergence as usual.
For example, without it $\al \le 1 \to \al$ would diverge.

\item[3. Solving existentials] Rules 12-17 are base cases where an existential variable is solved.
They all remove an existential variable and substitute the
variable with its solution in the remaining worklist. Importantly the rules
respect the scope of existential variables. For example, rule 12 
states that an existential variable $\al$ can be solved with another
existential variable $\bt$ only if $\bt$ occurs after $\al$.

\item[4. Checking judgements]
Rules 18-21 deal with checking judgments.
Rule 18 is similar to $\mathtt{DeclSub}$, but rewritten in the
continuation-passing-style.
\bruno{The side condition needs to be explained, and some mention of
  the overlapping is probably needed here.}
Rules 19 and 20 adapt their declarative counterparts to the worklist style.
Rule 21 is a special case of $\mathtt{Decl\to I}$.\bruno{Rule 21
  deserves some more explanation. What is the motivation for this
  rule? You may want to give some concrete example to motivate it.}
The same instantiation technique as in Rules 10 and 11 applies.
The declarative checking rule $\mathtt{Decl1I}$ does not have a direct counterpart in the algorithm, 
because Rules 18 and 24 can be combined to give the same result.

\item[5. Inference judgments]
Rules 22-26 deal with inference judgments.
Inference judgment chains are written in continuation-passing-style.
When an inference judgment succeeds with type $A$,
the algorithm continues to work on the inner-chain $\jg$ by assigning $A$ to its placeholder variable $a$.
Rule 23 infers an annotated expression by changing into checking mode,
therefore another judgment chain is created.
Rule 25 infers the type of a lambda expression by introducing $\al, \bt$
as the input and output types of the function, respectively.
After checking the body $e$ under the assumption $x:\al$,
the return type might reflect more information than simply $\al \to \bt$.
The variable scopes are maintained during the process:
the assumption of argument type ($x:\al$) is recycled after checking against the function body;
the declaration of the function type ($\al,\bt$) is only visible to
the checking and the remaining chain $[\al\to\bt/a]\jg$.
\bruno{You have some note ``differs'' on the rules. Should that
  deserve an explanation here?}

\item[6. Application inferences judgements]
Finally, Rules 27-29 deal with application inference judgments.
Rules 27 and 28 behaves similarly to declarative rules $\mathtt{Decl\forall App}$ and $\mathtt{Decl\to App}$.
Rule 29 instantiates $\al$ to the function type $\al[1] \to \al[2]$, just like Rules 10, 11 and 21.

\end{description}


\paragraph{Example}

\begin{figure}
\begin{gather*}
\begin{aligned}
           & \nil \Vdash (\lam x)~() \Lto 1\\
\rrule{18} & \nil \Vdash (\lam x)~() \To_a a\le 1\\
\rrule{26} & \nil \Vdash (\lam x) \To_b (\appInfAlg{b}{()}[a][a\le 1])\\
\rrule{25} & \nil,\al,\bt \Vdash \appInfAlg{\al\to\bt}{()}[a][a\le 1], x:\al \Vdash x\Lto \bt\\
\rrule{18} & \nil,\al,\bt \Vdash \appInfAlg{\al\to\bt}{()}[a][a\le 1], x:\al \Vdash x\To_b b\le \bt\\
\rrule{22} & \nil,\al,\bt \Vdash \appInfAlg{\al\to\bt}{()}[a][a\le 1], x:\al \Vdash \al\le \bt\\
\rrule{12} & \nil,\al \Vdash \appInfAlg{\al\to\al}{()}[a][a\le 1], x:\al\\
\rrule{3}  & \nil,\al \Vdash \appInfAlg{\al\to\al}{()}[a][a\le 1]\\
\rrule{28} & \nil,\al \Vdash \al\le 1 \Vdash () \Lto \al\\
\rrule{18} & \nil,\al \Vdash \al\le 1 \Vdash () \To_a a\le \al\\
\rrule{24} & \nil,\al \Vdash \al\le 1 \Vdash 1\le \al\\
\rrule{16} & \nil \Vdash 1\le 1\\
\rrule{4}  & \nil
\end{aligned}
\end{gather*}
\caption{A Sample Derivation for Algorithmic Typing}
\label{fig:alg:sample}
\end{figure}

Figure~\ref{fig:alg:sample} shows a sample derivation of the
algorithm.
\bruno{Derivation should be explained briefly at least.}

\paragraph{Non-overlapping and Deterministic Reduction}
An important feature of our algorithmic rules is that they are directly
implementable. Indeed, although written in the form of reduction rules, they do
not overlap and are thus deterministic.  This has the added benefit that our
algorithm runs in polynomial time, which makes it suitable for practical use.

Consider in particular Rules 8 and 9, which correspond to the declarative rules
$\mathtt{{\le}\forall L}$ and $\mathtt{{\le}\forall R}$. While those
declarative rules both match the goal $\all A\le \all[b]B$,
we have eliminated this overlap in the algorithm by restricting Rule 8
($B\neq\all B'$) and thus always applying Rule 9 to $\all A\le \all[b]B$.

Similarly, the declarative rule $\mathtt{DeclSub}$ overlaps highly with the
other checking rules. Its algorithmic counterpart is Rule 18. Yet, we have
avoided the overlap with other algorithmic checking rules by adding
side-conditions to Rule 18, namely $e\neq\lam e'$ and $B\neq\all B'$.

Such restrictions are not arbitrarily imposed:
we foramlly proved that the restricted algorithm is still complete.
In Section~\ref{sec:metatheory:non-overlapping} we discuss the relavant metatheory,
with the help of a restricted version of declarative system.

