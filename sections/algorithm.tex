\section{Algorithm}

\subsection{Syntax and Well-Formedness}

Figure~\ref{fig:alg:syntax} shows the
syntax and the well-formedness judgement.

\begin{figure}
\begin{gather*}
\begin{aligned}
\text{Type variables}\qquad&a, b\\
\text{Existential variables}\qquad&\al, \bt
\\[2mm]
%\text{Types}\qquad&A', B', C' &::=&\quad 1 \mid a \mid \forall x. A' \mid A'\to B'\\
\text{Mono-types}\qquad&\tau &::=&\quad 1 \mid a \mid \tau_1\to \tau_2\\
%\text{Context}\qquad&\Psi &::=&\quad \nil \mid \Psi, a \mid \Psi, x:A' \color{red} \\[2mm]
% \text{Declarative Judgements}\qquad&\jo &::=&\quad \nil \mid \P\vdash A' \le B' \jc \jo\\
% &&&\quad \mid \P\vdash e\Leftarrow A' \jc \jo \mid \P\vdash e\To A' \jc \jo \mid \P\vdash A' \bullet e\TTo C' \jc \jo\\
% \noalign{\jimmy{\text{What do the markers do: $\G \vdash,a \vdash,b\vdash \j_1;\j_2;\j_3$ means $\G,a,b\vdash \j_1 \land \G,a\vdash \j_1,\j_2 \land \G\vdash \j_3$}}} \\[2mm]
\text{Algorithmic types}\qquad&A, B, C &::=&\quad 1 \mid a \mid \al \mid \forall a. A \mid A\to B
\\[2mm]
\text{Terms}\qquad&e&::=&\quad x \mid () \mid \lam{e} \mid e_1~e_2 \mid (e:A)
\\[2mm]
\text{Algorithmic judgement chain}\qquad&\jg &::=&\quad A \le B \mid e\Lto A \mid e\To_{a} \jg \mid \appInfAlg{A}{e}
\\[2mm]
\text{Algorithmic worklist}\qquad&\Gm &::=&\quad \nil \mid \Gm, a \mid \Gm, \al \mid \Gm, x: A \mid \Gm \Vdash \jg\\
\text{Declarative worklist}\qquad&\Om &::=&\quad \nil \mid \Gm, a \mid \Gm, x: A \mid \Gm \Vdash \jg
\end{aligned}
\end{gather*}

\framebox{$\Gm\vdash\jg$} Well-formed algorithmic judgment
\begin{gather*}
\inferrule*[right=$\mathtt{wf{\le}}$]
{\Gm\vdash A \\ \Gm\vdash B}
{\Gm\vdash A\le B}
\qquad
\inferrule*[right=$\mathtt{wf{\Lto}}$]
{\Gm\vdash e \\ \Gm\vdash A}
{\Gm\vdash e \Lto A}
\\
\inferrule*[right=$\mathtt{wf{\To}}$]
{\Gm\vdash e \\ \Gm, a\vdash \jg}
{\Gm\vdash e \To_a \jg}
\qquad
\inferrule*[right=$\mathtt{wf{\TTo}}$]
{\Gm\vdash A \\ \Gm, a\vdash \jg \\ \Gm\vdash e}
{\Gm\vdash \appInfAlg{A}{e}}
\end{gather*}

\framebox{$\text{wf }\Gm$} Well-formed algorithmic worklist
\begin{gather*}
\inferrule*[right=$\mathtt{wf\nil}$]
{~}{\text{wf }\nil}
\qquad
\inferrule*[right=$\mathtt{wf_a}$]
{\text{wf }\Gm}
{\text{wf }\Gm, a}
\qquad
\inferrule*[right=$\mathtt{wf_{\al}}$]
{\text{wf }\Gm}
{\text{wf }\Gm, \al}
\qquad
\inferrule*[right=$\mathtt{wf_{of}}$]
{\text{wf }\Gm \\ \Gm\vdash A}
{\text{wf }\Gm, x:A}
\qquad
\inferrule*[right=$\mathtt{wf_{\jg}}$]
{\text{wf }\Gm \\ \Gm\vdash\jg}
{\text{wf }\Gm \Vdash\jg}
\end{gather*}
\caption{Syntax and Well-Formedness for the Algorithmic System}\label{fig:alg:syntax}
\end{figure}

\paragraph{Existential Variables} ...

\paragraph{Judgments and judgment chains} Judgment is a core component of algorithmic type-checking.
There are four kinds of judgments in our system: subtyping, checking, inference and application inference.
Subtyping and checking are relatively simple, since the result could be either success or fail, and no values will be returned.
For inference and application inference, they would return some type that leads to further computation, so we use continuation-passing-style encodings for them.
For example, a judgment chain $e \To_a (a \le B)$ contains two judgments: first we want to infer the type of the expression $e$, and then check if that type is a subtype of $B$.
In the rest of the paper, we usually refer to ``judgment chains'' by ``judgments''.

\paragraph{Worklist Judgments} Our algorithm has a non-standard form.
We combine the traditional contexts and judgment(s) into a single worklist.
The worklist collects variable bindings and judgments in \emph{order}, which represents their scopings:
each variable is visible only after it is declared.
For example, $[a,x:a,x \Lto a]$ is a valid worklist, but $[\textcolor{red}{x} \Lto a, x:\textcolor{red}{a},a]$ is not (red-colored symbols are out-of-scope).

\paragraph{Hole Notation}...

\subsection{Algorithmic System}

\newcounter{algRuleCounter}
\newcommand \algrule {\stepcounter{algRuleCounter}\rrule{\arabic{algRuleCounter}}}

% TODO rules too long
\begin{figure}[t]
\framebox{$\Gm\rto \Gm'$} $\Gm$ reduces to $\Gm'$.
%\jimmy{Whenever there is a change on judgment count, marker should be properly added/removed. Decidability: all valid judgment chain should be reduced to nil.}
\begin{gather*}
\begin{aligned}
\Gm, a &\algrule \Gm \qquad
\Gm, \al \algrule \Gm \qquad
\Gm, x:A \algrule \Gm
\\[2mm]
\Gm \Vdash 1\le 1 &\algrule \Gm\\
\Gm \Vdash a\le a &\algrule \Gm\\
\Gm \Vdash \al\le \al &\algrule \Gm\\
\Gm \Vdash A_1\to A_2 \le B_1\to B_2 &\algrule \Gm \Vdash A_2 \le B_2 \Vdash B_1\le A_1\\
\Gm \Vdash \forall a. A\le B &\algrule \Gm,\al \Vdash [\al/a]A\le B \quad\text{\jimmy{No more exvar leaks}}\\
\Gm \Vdash A\le \forall b. B &\algrule \Gm,b \Vdash A\le B \quad\text{\jimmy{No more typevar leaks}}
\\[2mm]
%\\
%\text{Let } \color{red}\Gm[\al \toto B // G_M] &:= \Gm_L, G_M, [B/\al]\Gm_R, \text{ when } \Gm[\al] = \Gm_L,\al,\Gm_R \ (G_M\text{ defaults to }\nil)\\
\Gm[\al] \Vdash \al \le A\to B &\algrule [\al[1]\to\al[2]/\al] (\Gm[\al[1], \al[2]] \Vdash \al[1]\to \al[2] \le A \to B)\\
 &\qquad \text{when }\al\notin FV(A)\cup FV(B)\\
\Gm[\al] \Vdash A\to B \le \al &\algrule [\al[1]\to \al[2]/\al] (\Gm[\al[1], \al[2]] \Vdash A \to B \le \al[1]\to \al[2])\\
 &\qquad \text{when }\al\notin FV(A)\cup FV(B)
 \\[2mm]
\Gm[\al][\bt] \Vdash \al \le \bt &\algrule [\al/\bt](\Gm[\al][])\\
\Gm[\al][\bt] \Vdash \bt \le \al &\algrule [\al/\bt](\Gm[\al][])\\
\Gm[a][\bt] \Vdash a \le \bt &\algrule [a/\bt](\Gm[a][])\\
\Gm[a][\bt] \Vdash \bt \le a &\algrule [a/\bt](\Gm[a][])\\
\Gm[\bt] \Vdash 1 \le \bt &\algrule [1/\bt](\Gm[])\\
\Gm[\bt] \Vdash \bt \le 1 &\algrule [1/\bt](\Gm[])
\\[2mm]
\Gm \Vdash e \Lto B &\algrule \Gm \Vdash e\To_a a\le B \quad \text{when } e \neq \lam e', B \neq \all B'\\
% \Gm \Vdash () \Lto 1 &\algrule \Gm\\
\Gm \Vdash e\Lto \forall a. A &\algrule \Gm,a \Vdash e\Lto A\\
\Gm \Vdash \lambda x. e \Lto A\to B &\algrule \Gm, x:A  \Vdash e \Lto B\\
\Gm[\al] \Vdash \lambda x. e \Lto \al &\algrule [\al[1]\to \al[2] / \al](\Gm[\al[1],\al[2]], x:\al[1] \Vdash e \Lto \al[2]) \quad\text{\jimmy{Additional}}
\\[2mm]
\Gm \Vdash x\To_a \jg &\algrule \Gm \Vdash [A/a] \jg \qquad (x:A)\in \Gm\\
\Gm \Vdash (e:A)\To_a \jg &\algrule \Gm \Vdash [A/a]\jg \Vdash e \Lto A\\
\Gm \Vdash ()\To_a \jg &\algrule \Gm \Vdash [1/a]\jg \qquad\jimmy{\downarrow\text{Precise control on exvars}}\\
\Gm \Vdash \lambda x. e \To_a \jg &\algrule
	\Gm,\al,\bt \Vdash [\al\to\bt/a]\jg, x:\al \Vdash e\Lto \bt \quad\jimmy{\text{differs}}\\
\Gm \Vdash e_1\ e_2 \To_a \jg &\algrule \Gm \Vdash e_1\To_{a_1} (\appInfAlg{a_1}{e_2})
\\[2mm]
\Gm \Vdash \appInfAlg{\forall a. A}{e} &\algrule \Gm,\al \Vdash \appInfAlg{[\al/a]A}{e}\\
\Gm \Vdash \appInfAlg{A\to C}{e} &\algrule \Gm \Vdash [C/a]\jg \Vdash e \Lto A\\
\Gm[\al] \Vdash \appInfAlg{\al}{e} &\algrule
	[\al[1]\to\al[2]/\al](\Gm[\al[1], \al[2]] \Vdash [\al[2]/a]\jg \Vdash e\Lto \al[1])\\
 &\color{magenta} \makebox[0pt]{\qquad or} \phantom{{}\rrule{}{}}
 	[\al[1]\to\al[2]/\al](\Gm[\al[1], \al[2]] \Vdash \appInfAlg{\al[1]\to\al[2]}{e})
\end{aligned}
\end{gather*}
\caption{Algorithmic Typing}\label{fig:alg}
\end{figure}

The algorithmic typing reduction rules, defined in Figure~\ref{fig:alg}, has the form $\Gm \rto \Gm'$,
where the worklists $\Gm, \Gm'$ contains variable declarations and judgments.
In every step it pops the first judgment from the worklist for processing,
possibly pushes new judgments to the worklist, and repeats this process until the list is empty.
A worklist that could be finally reduced to empty is considered to be successfully type-checked.
When the first element is a variable declaration, we simply continue the process (Rules 1-3).
The other rules always deal with the first judgment in the worklist. Logically we can discern 6 group of rules.

Firstly, we have six rules (Rules 4-9) that are similar to those of declarative subtyping.
For instance, Rule 7 consumes one subtyping judgment and pushes two back to the worklist.
Rule 8 differs from declarative Rule ${\le}{\forall}L$ by introducing an existential variable $\al$ instead of guessing the mono-type $\tau$ for instantiation.
Each existential variable is later solved to a mono-type $\tau$ with the same context,
so the final solution of $\al$, $\tau$, should be well-formed under context $\Gm$.

\paragraph{Variable scopings within worklist}
Rules 8 and 9 involve variable declaration, which demonstrates how our worklist treats variable scopings.
Rule 8 introduces an existential variable $\al$ that is only visible to the judgment $[\al/a]A \le B$.
Then reduction continues until all the subtyping judgments after $\al$ are satisfied.
Finally we can safely remove $\al$ since no occurrence of $\al$ could leak to its left in the worklist.
On the other hand, removing $\al$ according to the algorithm carbage-collects the variable at the perfect time: it leaves the environment immediately after unreferenced.

The design of our judgment chain is closely related to the property of the judgments.
Subtyping and checking does not return anything, so variables cannot leak anyway, as applied to Rules 8 and 9.
However, inference and application inference may return a type that contains new variables.
Take Rule 26 as an example, if it simply returns $\al \to \bt$, passes that to the next judgment and continues the type-checking process,
variables $\al$ and $\bt$ in the next judgment are out of scope
and will break the well-formedness of the worklist.
By making use of the continuation-passing-style judgement chain,
inner judgments always shares context with its parent judgment,
therefore we preserve well-formedness during reduction.

