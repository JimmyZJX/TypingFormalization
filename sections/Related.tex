\section{Related Work}

Throughout the paper we have already discussed much of the closest related work.
In this section we summarize the key differences and novelties, and we discuss some other
related work.

\bruno{Jimmy, please fill in missing references.}

\paragraph{Predicative Higher-Ranked Polymorphism Type Inference Algorithms}
Higher-ranked polymorphism is a convenient and practical feature of
programming languages.  Since full type-inference for System F is
undecidable~\cite{wells1999typability}, various decidable partial
type-inference algorithms were developed~\cite{}.  The declarative system of
this paper, proposed by \citet{dunfield2013complete}, is \emph{predicative}: 
$\forall$'s only instantiate to monotypes.  The monotype restriction
on instantiation is considered reasonable and practical for most
programs, except for those that require sophisticated forms of
higher-order polymorphism.  In those cases, the bidirectional system
accepts guidance through type annotations, which allow polymorphic types.
Such annotations also improve
readability of the program, and are not much of a burden in practice.

\jimmy{Dunfield's new work}
DK's algorithm is shown to be sound, complete and decidable in 70 pages of manual proofs.
Though carefully written, some of the proofs are incorrect (see discussion in Appendix),
which creates difficulties when formalizing them in a proof assistant.
Their follow-up work~\cite{} enriches the bidirectional higher-rank system with
existentials and indexed types.
With a more complex declarative system, they developed a proof of over 150 pages.
It is even more difficult to argue its correctness for every single detail within such a big development.
Unfortunately, we find that their Lemma 26 (Parallel Admissibility) appears to have the same issue 
as lemma 29 discussed in Appendix: the conclusion is false.
\bruno{I think you will need to justify this better and in the appendix you must show
the lemma and counter-example.}
\bruno{Missing Simon Peyton Jones work: which is the other predicative work.
  Maybe the OutsideIn work can also be briefly mentioned (you can ask Tom for details
  of that work).
 }

\paragraph{Impredicative Higher-Ranked Polymorphism Type Inference Algorithms}
Impredicative System F allows instantiation with polymorphic types,
but unfortunately its subtyping system is already undecidable~\cite{tiuryn1996subtyping}.
Works on partial impredicative type-inference algorithms\cite{le2003ml,leijen2008hmf,vytiniotis2008fph}
navigate a variety of design tradeoffs for a decidable algorithm.
As a result, such algorithms tend to be more complicated, and thus less adopted in practise.
\jimmy{Guarded Impredicative}
A recent work proposed Guarded Impredicative Polymorphism~\cite{},
as an improvement on GHC's type inference algorithm with impredicative instantiation.
They make use of local informations in $n$-ary applications to
infer polymorphic instantiations with a relatively simple specification and unification algorithm.
Although not all impredicative instantiations can be handled well,
their algorithm is already quite useful in practice.

\paragraph{Mechanical Formalization of Polymorphic Subtyping}
In all previous work on type inference for higher-ranked polymorphism
(predicative and impredicative) discussed above, all proofs and
metatheory are manual. The only partial effort on mechanizing aspects of type inference
for higher-ranked types is
the Abella formalization of \emph{polymorphic subtyping} by \citet{itp2018}.
The judgment form of worklist $\Gm \vdash \Omega$ used in the formalization simplifies
the propagation of existential variable instantiations.
However, the approach has two main drawbacks;
it does not collect unused variable declarations effectively,
and the simple form of judgment cannot handle inference modes, which outputs types.
The new worklist introduced in this paper inherits the simplicity of propagating instantiations,
but overcome both of the issues by mixing judgments with declarations
and using the continuation-passing-style judgment chains.
\bruno{a comparison with our own ITP paper here!}

\paragraph{Mechanical Formalizations of Other Type-Inference Algorithms}
Since the publication of the {\sc POPLMark} challenge~\cite{aydemir2005mechanized},
many theorem provers and packages provide new methods for dealing
with variable binding~\cite{aydemir2008engineering,urban2008nominalTech,chlipala2008parametric}.
More and more type systems are formalized with these tools.
However, mechanising certain algorithmic aspects, like unification and
constraint solving, has received very little attention and are still challenging.
Moreover, while most tools supports local (input) contexts in a neat way, which have a simple
binding and scoping structure, many practical type-inference algorithms require
more complex binding structures with output contexts or various forms of constraint solving procedures.

Algorithm $\mathcal{W}$,
as one of the classic type inference algorithms for polymorphic type systems,
has been manually proven to be sound and complete
with respect to the Hindley-Milner type system~\cite{}.
After around 15 years, the algorithm was formally verified by
\citet{naraschewski1999type} in Isabelle/HOL~\cite{nipkow2002isabelle}.
The treatment of new variables was tricky at that time, while the overall structure follow the
structure of Damas's manual proof closely.
%Another complication is the encoding of substitutions,
%which they chose to formalize as a function instead of an association list.
Later on, other researchers~\cite{dubois2000proving,dubois1999certification}
formalized algorithm $\mathcal{W}$ in Coq~\cite{Coq}.
Nominal techniques~\cite{urban2008nominalTech} in Isabelle/HOL have been
developed to help programming language formalizations, and are used for a similar
verification~\cite{urban2008nominal}. Moreover, Garrigue~\cite{garrigue2015certified}
mechanized a type inference algorithm,
with the help of locally nameless cofinite quantification~\cite{},
for Core ML extended with structural polymorphism and recursion.

\paragraph{Ordered Contexts in Type Inference}
Gundry et al.~\cite{gundry2010type}

\paragraph{Lists of Judgements in Unification}
Some work~\cite{Reed2009,Abel2011higher} adopts a similar idea to this paper
in dependently typed inference and reconstruction.
Their algorithms collect unification constraints and simplify them progressively in a single-step style.
In comparison, our algorithm mixes variable declarations with judgments,
resulting in a simpler judgment form,
while processing them in a similar way to those algorithms.
A detailed discussion is in Section~\ref{sec:overview:list}.

\bruno{Missing: work on type inference and unification of dependent types.
  Also missing: discussion about ordered contexts and the work by Gundry (in addition to DK).
  Regarding these two, since we have an extended discussion in Section 2 you can have
  a summarized discussion here, pointoing to Section 2 for further deatils.}

\bruno{Final comment: You should essentially have all the discussion that we have in ITP +
  some more. So, double-check carefully that all the works we cite in our related work in ITP
are cited here, and that we include all discussions!}
