\section{Metatheory}

\subsection{Transfer to the Declarative System}
%\jimmy{The transfer rule outputs declarative judgment chains, which are later processed by another declarative relation, handling all the guessing.}

\begin{figure}[t]
\framebox{$\Gm \sto \Om$} $\Gm$ transfers to $\Om$.
\begin{gather*}
\inferrule*[right=$\mathtt{{\sto}}\Om$]
{~}
{\Om \sto \Om}
\quad
\inferrule*[right=$\mathtt{{\sto}\al}$]
{\Om\vdash\tau \\ \Om,[\tau/\al]\Gm \sto \Om}
{\Om,\al,\Gm \sto \Om}
\end{gather*}
\caption{Transfer Rules}
\label{fig:trans}
\end{figure}

The transfer rules are shown in Figure~\ref{fig:trans}.
Rule $\mathtt{{\sto}\al}$ recursively replace the first existential variable to a well-scoped mono-type
($\Om$, as a declarative worklist, contains no existential variables),
so the algorithmic worklist will finally become a declarative one.
In order to maintain well-formedness,
the substitution should affect all the judgments and term variable bindings in the scope of $\al$.

The transfer $\Gm\sto\Om$ is not a function.
On the one hand, there are infinite possibilities to instantiate an existential variable,
thus a $\Gm$ could be transferred to different $\Om$'s.
On the other hand, any valid mono-type in $\Om$ can be represented by an existential variable in $\Gm$,
thus different $\Gm$'s could be transferred to a single $\Om$.

The following lemmas~\ref{lem:insert} and \ref{lem:extract}
generalize Rule $\mathtt{{\sto}\al}$ from substituting the first existential variable
to substituting any existential variable.

\begin{lemma}[Insert]\label{lem:insert}
If $\Gm_L\vdash \tau$ and $\Gm_L, [\tau/\al]\Gm_R \sto \Om$
, then $\Gm_L, \al, \Gm_R \sto \Om$.
\end{lemma}
\begin{lemma}[Extract]\label{lem:extract}
If $\Gm_L, \al, \Gm_R \sto \Om$
, then $\exists \tau$ s.t. $\Gm_L\vdash\tau$ and $\Gm_L, [\tau/\al]\Gm_R \sto \Om$.
\end{lemma}

\begin{figure}[t]
\framebox{$\Om \rto \Om'$} $\Om$ reduces to $\Om'$.
\begin{gather*}
\begin{aligned}
\Om,a &\rto \Om \qquad \Om \qquad \Om,x:A \rto \Om\\
\Om\Vdash A\le B &\rto \Om \text{ when } \Om\vdash A\le B\\
\Om\Vdash e\Lto A &\rto \Om \text{ when } \Om\vdash e\Lto A\\
\Om\Vdash e\To_a \jg &\rto \Om\Vdash[A/a]\jg \text{ when } \Om\vdash e\To A\\
\Om\Vdash \appInfAlg{A}{e} &\rto \Om\Vdash[C/a]\jg \text{ when } \Om\vdash \appInf{A}{e}{C}\\
\end{aligned}
\end{gather*}
\caption{Declarative Worklist Typing}
\label{fig:decl:worklist}
\end{figure}

Figure~\ref{fig:decl:worklist} relates the worklist-style declarative system
to the original declarative system.
A successful reduction means a valid variable declaration,
a valid subtyping or checking judgment, or a successful guessing for inferences.
Additionally, judgment chains are unfolded to match the original declarative rules.
Although $\Om$ is defined differently from $\Psi$,
our declarative worklist $\Om$ contains a ordered collection of variable definitions,
which naturally fits declarative subtyping and typing.

\subsection{Soundness}

Our algorithm is sound with respect to the declarative system.
For any worklist $\Gm$ that reduces successfully,
we can find a valid transfer $\Gm\sto\Om$ that solves all the existential variables,
such that $\Om$ also reduces successfully.
\begin{theorem}[Soundness]
If \emph{wf }$\Gm$ and $\Gm \redto \nil$, then $\exists \Om$ s.t. $\Gm\sto\Om$ and $\Om\redto\nil$.
\end{theorem}

The proof proceeds by induction on derivation of $\Gm\redto\nil$.
Proper applications of lemmas \ref{lem:insert} and \ref{lem:extract} finish off the theorem.

\subsection{Completeness}

Completeness of the algorithm means that any declarative system has an algorithmic counterpart.

\begin{theorem}[Completeness]
If \emph{wf }$\Gm$ and $\exists \Om$ s.t. $\Gm\sto\Om$ and $\Om\redto\nil$, then $\Gm \redto \nil$.
\end{theorem}

We prove completeness by induction on the derivation of $\Om\redto\nil$.
Since the declarative worklist is reduced judgment-by-judgment,
the induction always analyse the first judgment until it is satisfied.
As the algorithmic system introduces existential variables,
a declarative rule may correspond to multiple algorithmic rules,
and thus we analyse each of the possible cases.

For subtyping, algorithmic Rules 10 and 11 worth special treatment.
When the induction reaches the $\mathtt{{\le}{\to}}$ case,
the first judgment is of shape $A_1 \to A_2 \le B_1 \to B_2$.
One of the corresponding algorithmic judgment is $\al \le A \to B$.
However, the case analysis does not imply that $\al$ is fresh in $A$ and $B$,
therefore Rule~10 cannot be applied and the proof get stuck.
The following lemma helps us out in those cases:
the success in declarative subtyping indicates the freshness of $\al$ in $A$ and $B$
in its corresponding algorithmic judgment.
In other words, the declarative system do not accept infinite types,
thus, as an example, we cannot find a mono-type $\tau$ such that $\tau\le 1\to \tau$,
which could be transferred by $\al\le 1\to\al$.

\begin{lemma}[Prune Transfer for Instantiation]
If $(\Gm \Vdash \al \le A \to B) \sto (\Om \Vdash C \le A_1 \to B_1)$ and
$\Om \vdash C \le A_1 \to B_1$, then $\al\notin FV(A) \cup FV(B)$.
\end{lemma}

A symmetric lemma holds for $A\to B \le \al$.

\subsection{Decidability}
\begin{theorem}[Decidability]
For all well-formed $\Gm$, it is decidable whether $\Gm\redto\nil$ or not.
\end{theorem}

lexicographic group of induction measurements
$\langle |\Gm|_e, |\Gm|_\Leftrightarrow, |\Gm|_\forall, |\Gm|_{\al}, |\Gm|_\to + |\Gm| \rangle$

\begin{definition}[Worklist Measures]
\begin{gather*}
\begin{aligned}
|\Gm|_e &= \textstyle\sum_{e\Lto A\in\Gm}|e|_e + \sum_{e\To_a \jg\in\Gm}|e|_e +
    \sum_{\appInfAlg{A}{e}\in\Gm}|e|_e\\
|\Gm|_\Leftrightarrow &= \#_{e\Lto A\in\Gm} +
    2\nil\#_{e\To_a \jg\in\Gm} + 3\nil\#_{\appInfAlg{A}{e}\in\Gm}\\
|\Gm|_\forall &= \textstyle\sum_{e\Lto A\in\Gm}|A|_\forall + \sum_{\appInfAlg{A}{e}\in\Gm}|A|_\forall +
    \sum_{A\le B\in\Gm} |A|_\forall + |B|_\forall\\
|\Gm|_\to &= \textstyle\sum_{e\Lto A\in\Gm}|A|_\to + \sum_{\appInfAlg{A}{e}\in\Gm}|A|_\to +
    \sum_{A\le B\in\Gm} |A|_\to + |B|_\to\\
|\Gm|_{\al} &= \#_{\al\in\Gm}\\
\end{aligned}
\end{gather*}
\end{definition}

\begin{figure}
\framebox{$\Gm\jExt\Gm'$}
\begin{gather*}
\inferrule*[right=$\mathtt{\jExt id}$]
    {~}{\Gm\jExt\Gm}
\qquad
\inferrule*[right=$\mathtt{\jExt solve}$]
    {|A|_\forall = 0 \quad \Gm_L,[A/\al]\Gm_R \jExt \Gm'}{\Gm_L,\al,\Gm_R \jExt \Gm'}
\qquad
\inferrule*[right=$\mathtt{\jExt \al}$]
    {\Gm_L,\al,\Gm_R \jExt \Gm'}{\Gm_L,\Gm_R \jExt \Gm'}
\end{gather*}
\caption{Worklist Extension}\label{fig:worklist_ext}
\end{figure}

Shown in Figure~\ref{fig:worklist_ext},
worklist extension relates minor changes of worklist during type-checking.
When the algorithm processes the worklist, the first judgment is processed,
and the rest of the worklist roughly remains its shape.
Worklist extension formally defines the minor changes of the shape by two cases:
existential variable solving ($\mathtt{\jExt solve}$) and
existential variable addition ($\mathtt{\jExt \al}$).
Existential variable instantiation,
i.e. $\Gm_L,\al,\Gm_R \jExt \Gm_L, \al[1], \al[2], [\al[1] \to \al[2] / \al]\Gm_R$,
can be derived with the combination of the 3 rules.

\subsection{Abella}
