Import "inst_decidable".

Theorem jExt_wfj : forall E Ext, jExt E Ext -> wfj E -> wfj Ext.
induction on 1. intros. case H1. search.
	apply wfj_remove_exvar_nabla to H3 H4 _ _. apply IH to H7 _. search.
	apply wfj_insert_exvar_raw to H3 H4 _. apply IH to H5 _. search.
%	apply wfj_insert_exvar to H3 H4 _. apply IH to H5 _. search.

Define tmSizeJ : judgment -> nat -> prop by
	tmSizeJ (subty A B) z;
	tmSizeJ (check X A) N := tmSize X N;
	tmSizeJ (inferC X Ji) K := exists M N, nabla x,
		tmSize X M /\ tmSizeJ (Ji x) N /\ add M N K;
	tmSizeJ (inferAppC A X Ji) K := exists M N, nabla x,
		tmSize X M /\ tmSizeJ (Ji x) N /\ add M N K.

Define tmSizel : olist -> nat -> prop by
	tmSizel nil z;
	nabla x, tmSizel (exvar x :: E x) N := nabla x, tmSizel (E x) N;
	nabla x, tmSizel (tyvar x :: E x) N := nabla x, tmSizel (E x) N;
	nabla x, tmSizel (of x A :: E x) N := nabla x, tmSizel (E x) N;
	tmSizel (j J :: E) K := exists M N, tmSizeJ J M /\ tmSizel E N /\ add M N K.

Theorem tmSizeJ_is_nat : forall J N, tmSizeJ J N -> is_nat N.
induction on 1. intros. case H1. search.
	backchain tmSize_is_nat.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.

Theorem nat_prune_ty : forall N, nabla (x : ty), is_nat (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem nat_prune_tm : forall N, nabla (x : tm), is_nat (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem tmSizel_is_nat : forall E N, tmSizel E N -> is_nat N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.

Theorem tmSizel_prune : forall E N, nabla (x : ty),
	tmSizel (E x) (N x) -> exists Nr, N = x\ Nr.
intros. apply tmSizel_is_nat to H1.
	apply nat_prune_ty to H2. search.

Theorem tmSizel_prune_tm : forall E N, nabla (x : tm),
	tmSizel (E x) (N x) -> exists Nr, N = x\ Nr.
intros. apply tmSizel_is_nat to H1.
	apply nat_prune_tm to H2. search.

Theorem tmSizeJ_subst_eq : forall J A N N1, nabla (x : ty),
	tmSizeJ (J x) N -> tmSizeJ (J (A x)) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply tmSize_subst to H3 with A = A. apply tmSize_det to H4 H5. search.
	case H2. apply tmSize_prune to H3.
		apply tmSize_subst to H3 with A = A. apply tmSize_det to H6 H9.
		apply tmSizeJ_is_nat to H4. apply nat_prune_ty to H10. apply add_prune[ty] to H8.
		apply IH to H4 _ with J = x\ Ji x n2, A = A.
		apply add_det to H5 H8. search.
	case H2. apply tmSize_prune to H3.
		apply tmSize_subst to H3 with A = A. apply tmSize_det to H6 H9.
		apply tmSizeJ_is_nat to H4. apply nat_prune_ty to H10. apply add_prune[ty] to H8.
		apply IH to H4 _ with J = x\ Ji x n2, A = A.
		apply add_det to H5 H8. search.

Theorem tmSizel_subst_eq : forall E A N N1, nabla (x : ty),
	tmSizel (E x) N -> tmSizel (E A) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply tmSizel_prune to H4.
		apply tmSizeJ_is_nat to H3. apply nat_prune_ty to H9.
		apply IH to H4 H7. apply tmSizeJ_subst_eq to H3 _ with A = x\ A.
		apply add_det to H5 H8. search.
Theorem tmSizel_det : forall E N N1, tmSizel E N -> tmSizel E N1 -> N = N1.
intros. apply tmSizel_subst_eq to H1 H2. search.

Theorem tmSizel_append : forall E F EF NE NF NEF, tmSizel E NE -> tmSizel F NF ->
	append E F EF -> add NE NF NEF -> tmSizel EF NEF.
induction on 1. intros. case H1.
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply tmSizel_prune_tm to H7. search.
	case H3. apply add_assoc to H7 _.
		apply IH to H6 _ _ _. search.

Theorem tmSizel_total_wfjg : forall E J, wfjg E J -> exists N, tmSizel (j J :: nil) N.
induction on 1. intros. case H1.
	search.
	apply tmSize_total to H2.
		N: apply tmSize_is_nat to H4.
		apply add_total to N with n = z. search.
	apply IH to H3. apply tmSize_total to H2.
		N: apply tmSize_is_nat to H5.
		case H4. case H7. apply add_z_eq to *H8.
		apply tmSizeJ_is_nat to H6. apply nat_prune_ty to H9.
		apply add_total to N with n = Nr.
		apply add_is_nat_k to _ H10. apply add_zero to H11.
		search.
	apply IH to H4. apply tmSize_total to H2.
		N: apply tmSize_is_nat to H6.
		case H5. case H8. apply add_z_eq to *H9.
		apply tmSizeJ_is_nat to H7. apply nat_prune_ty to H10.
		apply add_total to N with n = Nr.
		apply add_is_nat_k to _ H11. apply add_zero to H12.
		search.


Theorem tmSizeJ_total : forall E J, wfjg E J -> exists N, tmSizeJ J N.
induction on 1. intros. case H1.
	search.
	apply tmSize_total to H2. search.
	apply tmSize_total to H2. apply IH to H3.
		apply tmSizeJ_is_nat to H5. apply nat_prune_ty to H6.
		apply tmSize_is_nat to H4. apply add_total to H7 with n = Nr. search.
	apply tmSize_total to H2. apply IH to H4.
		apply tmSizeJ_is_nat to H6. apply nat_prune_ty to H7.
		apply tmSize_is_nat to H5. apply add_total to H8 with n = Nr. search.

Theorem tmSizel_total_wfj : forall E, wfj E -> exists N, tmSizel E N.
induction on 1. intros. case H1.
	search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply tmSizeJ_total to H3.
		apply tmSizeJ_is_nat to H5. apply add_total to H6 with n = N. search.

Theorem tmSizel_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, tmSizel F NF /\ tmSizel E NE /\ tmSizel FE NFE /\ add NF NE NFE.
induction on 2. intros. case H2.
	case H1. search.
	case H1. apply IH to _ H3. search.
		apply append_prune to H4. apply IH to H4 H3. search.
	case H1. apply IH to _ H3. search.
		apply append_prune to H4. apply IH to H4 H3. search.
	case H1. apply IH to _ H3. search.
		apply append_prune_tm to H5. apply IH to H5 H3. search.
	apply tmSizeJ_total to H4. apply tmSizeJ_is_nat to H5.
		case H1. apply IH to _ H3. apply add_total to H6 with n = NE. search.
		apply IH to _ H3. apply add_total to H6 with n = NFE.
			apply add_assoc_inv to H11 H12. search.

Theorem tmSizel_total_nat : forall E, wfj E -> exists NE, tmSizel E NE /\ is_nat NE.
intros. apply tmSizel_total_wfj to H1. apply tmSizel_is_nat to H2. search.

Theorem jExt_tmSizel_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> tmSizel E NE -> tmSizel Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply tmSizel_det to H3 H4. search.
	apply tmSizel_total_FE to H5 _. case H11. apply tmSizel_det to *H3 H12.
		apply tmSizel_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply tmSizel_total_wfj to W.
		apply IH to _ H9 H16 H4.
		apply tmSizel_prune to H15. apply tmSizel_subst_eq to H15 H16. search.
	apply tmSizel_total_FE to H5 _. apply tmSizel_det to *H3 H10.
		apply tmSizel_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply tmSizel_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply tmSizel_prune to H13. apply tmSizel_det to H12 H13. search.
Theorem jExt_tmSizel : forall E Ext NE,
	wfj E -> jExt E Ext -> tmSizel E NE -> tmSizel Ext NE.
intros. apply jExt_wfj to _ _. apply tmSizel_total_wfj to H4.
	apply jExt_tmSizel_eq to _ _ H3 H5. search.

% Theorem tmSizel_subst_tyvar : forall E J m N, nabla x,
% 	tmSizel (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> wfj (j (J m) :: E) /\ tmSizel (j (J m) :: E) N.
% intros. T: apply tmSizel_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply tmSizel_total_FE to _ W with E = E.
% 	T: case T1. apply tmSizel_det to T5 *T1.
% 	apply tmSizel_prune to T. apply tmSizel_subst_eq to T T4.
% 	apply add_det to T3 T7. apply tmSizel_det to H1 T2. search.


Define m_judgeJ : judgment -> nat -> prop by
	m_judgeJ (subty A B) z;
	m_judgeJ (check X A) (s (s z));
	m_judgeJ (inferC X Ji) (s N) := nabla x, m_judgeJ (Ji x) N;
	m_judgeJ (inferAppC A X Ji) (s (s (s N))) := nabla x, m_judgeJ (Ji x) N.

Theorem m_judgeJ_is_nat : forall J N, m_judgeJ J N -> is_nat N.
induction on 1. intros. case H1.
	search. search.
	apply IH to H2. search.
	apply IH to H2. search.

Define m_judge : olist -> nat -> prop by
	m_judge nil z;
	nabla x, m_judge (exvar x :: E x) N := nabla x, m_judge (E x) N;
	nabla x, m_judge (tyvar x :: E x) N := nabla x, m_judge (E x) N;
	nabla x, m_judge (of x A :: E x) N := nabla x, m_judge (E x) N;
	m_judge (j J :: E) K := exists M N,
		m_judgeJ J M /\ m_judge E N /\ add M N K.

Theorem m_judge_is_nat : forall E N, m_judge E N -> is_nat N.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to H5 H4. search.

Theorem m_judge_prune : forall E N, nabla (x : ty),
	m_judge (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search.
	apply IH to H3. apply m_judge_is_nat to H3.
		apply add_is_nat_k to _ H4. apply nat_prune_ty to H6. search.

Theorem m_judge_prune_tm : forall E N, nabla (x : tm),
	m_judge (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H2 with x = n1. search. apply IH to H2. search.
	apply IH to H3. apply m_judge_is_nat to H3.
		apply add_is_nat_k to _ H4. apply nat_prune_tm to H6. search.

Theorem m_judgeJ_subst_eq : forall J A N N1, nabla (x : ty),
	m_judgeJ (J x) N -> m_judgeJ (J (A x)) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. search.
	case H2. apply IH to H3 _ with J = x\ Ji x n2, A = A. search.
	case H2. apply IH to H3 _ with J = x\ Ji x n2, A = A. search.

Theorem m_judge_subst_eq : forall E A N N1, nabla (x : ty),
	m_judge (E x) N -> m_judge (E A) N1 -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H3 with x = n2. apply IH to H3 H4. search.
	case H2. apply IH to H3 _ with A = A n2. search.
	case H2. apply m_judge_prune to H4.
		apply IH to H4 _ with A = A.
		apply m_judgeJ_is_nat to H3. apply nat_prune_ty to H9.
		apply m_judgeJ_subst_eq to H3 H6.
		backchain add_det.
Theorem m_judge_det : forall E N N1, m_judge E N -> m_judge E N1 -> N = N1.
intros. apply m_judge_subst_eq to H1 H2. search.

Theorem m_judge_append : forall E F EF NE NF NEF,
	m_judge E NE -> m_judge F NF ->
	append E F EF -> add NE NF NEF -> m_judge EF NEF.
induction on 1. intros. case H1.
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply m_judge_prune_tm to H7. search.
	case H3. apply add_assoc to H7 H4. apply IH to H6 _ _ _. search.

Theorem m_judgeJ_total_wfjg : forall E J, wfjg E J -> exists N, m_judgeJ J N.
induction on 1. intros. case H1. search. search.
	apply IH to H3. apply m_judgeJ_is_nat to H4. apply nat_prune_ty to H5. search.
	apply IH to H4. apply m_judgeJ_is_nat to H5. apply nat_prune_ty to H6. search.

Theorem m_judge_total_wfj : forall E, wfj E -> exists N, m_judge E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2.
		apply m_judgeJ_total_wfjg to H3. apply m_judgeJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem m_judge_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, m_judge F NF /\ m_judge E NE /\
		m_judge FE NFE /\ add NF NE NFE.
induction on 1. intros. case H1.
	apply m_judge_total_wfj to H2. search.
	W: case H2.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune_tm to H3. apply IH to H3 _. search.
		apply IH to H3 _. apply m_judgeJ_total_wfjg to W1.
			N: apply m_judgeJ_is_nat to H8.
			apply add_total to N with n = NFE.
			apply add_assoc_inv to H7 H9. search.

Theorem m_judge_total_nat : forall E, wfj E -> exists NE, m_judge E NE /\ is_nat NE.
intros. apply m_judge_total_wfj to H1. apply m_judge_is_nat to H2. search.

Theorem jExt_m_judge_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> m_judge E NE -> m_judge Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply m_judge_det to H3 H4. search.
	apply m_judge_total_FE to H5 _. case H11. apply m_judge_det to *H3 H12.
		apply m_judge_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply m_judge_total_wfj to W.
		apply IH to _ H9 H16 H4.
		apply m_judge_prune to H15. apply m_judge_subst_eq to H15 H16. search.
	apply m_judge_total_FE to H5 _. apply m_judge_det to *H3 H10.
		apply m_judge_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply m_judge_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply m_judge_prune to H13. apply m_judge_det to H12 H13. search.
Theorem jExt_m_judge : forall E Ext NE,
	wfj E -> jExt E Ext -> m_judge E NE -> m_judge Ext NE.
intros. apply jExt_wfj to _ _. apply m_judge_total_wfj to H4.
	apply jExt_m_judge_eq to _ _ H3 H5. search.

% Theorem m_judge_subst_tyvar : forall E J m N, nabla x,
% 	m_judge (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> wfj (j (J m) :: E) /\ m_judge (j (J m) :: E) N.
% intros. T: apply m_judge_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply m_judge_total_FE to _ W with E = E.
% 	T: case T1. apply m_judge_det to T5 *T1.
% 	apply m_judge_prune to T. apply m_judge_subst_eq to T T4.
% 	apply add_det to T3 T7. apply m_judge_det to H1 T2. search.


Theorem orderl_append : forall E F EF NE NF NEF,
	orderl E NE -> orderl F NF ->
	append E F EF -> add NE NF NEF -> orderl EF NEF.
induction on 1. intros. case H1 (keep).
	case H3. case H4. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune to H7. search.
	case H3. apply IH to H5 _ _ _. apply orderl_prune_tm to H7. search.
	case H3. apply add_assoc to H7 _. apply IH to H6 _ _ _. search.

Theorem orderJ_total_wfjg : forall E J, wfjg E J -> exists N, orderJ J N.
induction on 1. intros. case H1.
	O: apply order_total_wf to H2. O: apply order_total_wf to H3.
		N: apply order_is_nat to O.
		apply add_total to N with n = m1. search.
	O: apply order_total_wf to H3. search.
	apply IH to H3. apply orderJ_prune to H4. search.
	O: apply order_total_wf to H3. N: apply order_is_nat to O.
		apply IH to H4. apply orderJ_prune to H5.
		apply add_total to N with n = Nr. search.

Theorem orderl_total_wfj : forall E, wfj E -> exists N, orderl E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply orderJ_total_wfjg to H3.
		apply orderJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem orderl_total_FE : forall F E FE, append F E FE -> wfj FE ->
	exists NF NE NFE, orderl F NF /\ orderl E NE /\
		orderl FE NFE /\ add NF NE NFE.
induction on 1. intros. case H1.
	apply orderl_total_wfj to H2. search.
	case H2.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune to H3. apply IH to H3 _. search.
		apply append_prune_tm to H3. apply IH to H3 _. search.
		apply IH to H3 _. apply orderJ_total_wfjg to H5.
			N: apply orderJ_is_nat to H10.
			apply add_total to N with n = NFE.
			apply add_assoc_inv to H9 _. search.

Theorem orderl_total_nat : forall E, wfj E -> exists NE, orderl E NE /\ is_nat NE.
intros. apply orderl_total_wfj to H1. apply orderl_is_nat to H2. search.

Theorem order_det : forall A N1 N2, order A N1 -> order A N2 -> N1 = N2.
induction on 1. intros. case H1.
	case H2. search.
	case H2. search.
	case H2. apply IH to H3 H6. apply IH to H4 H7. apply add_det to H5 H8. search.
	case H2. apply IH to H3 H4. search.

Theorem order_subst_eq : forall A a N N1, nabla (x : ty),
	order (A x) N -> order (A a) N1 -> order a z -> N = N1.
induction on 1. intros. case H1 (keep).
	case H2. search.
	case H2. search.
	apply order_det to H2 H3. search.
	apply order_prune to H4. apply order_prune to H5.
		case H2. apply IH to H4 _ _. apply IH to H5 _ _. apply add_det to H6 H9. search.
	case H2. apply IH to H4 _ _. search.

Theorem orderJ_subst_eq : forall J A N N1, nabla (x : ty),
	orderJ (J x) N -> orderJ (J A) N1 -> order A z -> N = N1.
induction on 1. intros. case H1.
	case H2. apply order_prune to H4. apply order_prune to H5.
		apply order_subst_eq to H4 _ H3. apply order_subst_eq to H5 _ H3.
		apply add_det to H6 H9. search.
	case H2. apply order_subst_eq to H4 _ H3. search.
	case H2. apply IH to H4 _ H3 with J = x\ Ji x n2. search.
	case H2. apply add_prune to H6. apply add_prune to H6. apply add_prune to H9.
		apply order_subst_eq to H4 _ H3.
		apply IH to H5 _ H3.
		apply add_det to H6 H9. search.

Theorem orderl_subst_eq : forall E A N N1, nabla (x : ty),
	orderl (E x) N -> orderl (E A) N1 -> order A z -> N = N1.
induction on 1. intros. case H1.
	case H2. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply orderl_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply orderl_prune to H4 with x = n2. apply IH to H4 H5 _. search.
	case H2. apply IH to H4 _ H3. search.
	case H2. apply add_prune to H6. apply IH to H5 _ H3.
		apply orderJ_subst_eq to H4 _ H3.
		apply add_det to H6 H9. search.
Theorem orderl_det : forall E N N1, orderl E N -> orderl E N1 -> N = N1.
intros. apply orderl_subst_eq to H1 H2 _. search.

% Theorem orderl_subst_tyvar : forall E J m N, nabla x,
% 	orderl (j (J x) :: tyvar x :: E) N -> wfj (j (J x) :: tyvar x :: E) ->
% 	wfta E m -> order m z -> wfj (j (J m) :: E) /\ orderl (j (J m) :: E) N.
% intros. T: apply orderl_total_FE to _ H2 with E = tyvar n1 :: E.
% 	W: apply wfj_subst_tyvar to H2 _.
% 	T: apply orderl_total_FE to _ W with E = E.
% 	T: case T1. apply orderl_det to T5 *T1.
% 	apply orderl_prune to T. apply orderl_subst_eq to T T4 _.
% 	apply add_det to T3 T7. apply orderl_det to H1 T2. search.

Theorem jExt_orderl_eq : forall E Ext NE NExt,
	wfj E -> jExt E Ext -> orderl E NE -> orderl Ext NExt -> NE = NExt.
induction on 2. intros. case H2 (keep).
	apply orderl_det to H3 H4. search.
	apply orderl_total_FE to H5 _. case H11. apply orderl_det to *H3 H12.
		apply orderl_append to _ _ H6 _.
		W: apply wfj_remove_exvar_nabla to H5 H6 _ _. apply orderl_total_wfj to W.
		apply IH to _ H9 H16 H4.
		apply orderl_prune to H15. apply orderl_subst_eq to H15 H16 _. search.
	apply orderl_total_FE to H5 _. apply orderl_det to *H3 H10.
		apply orderl_append to _ _ H6 _.
		W: apply wfj_insert_exvar_raw to H5 H6 _. apply orderl_total_wfj to W.
		apply IH to _ H7 H13 H4.
		apply orderl_prune to H13. apply orderl_det to H12 H13. search.
Theorem jExt_orderl : forall E Ext NE,
	wfj E -> jExt E Ext -> orderl E NE -> orderl Ext NE.
intros. apply jExt_wfj to _ _. apply orderl_total_wfj to H4.
	apply jExt_orderl_eq to _ _ H3 H5. search.


Define depthJ : judgment -> nat -> prop by
	depthJ (subty A B) K := exists M N, depth A M /\ depth B N /\ add M N K;
	depthJ (check X A) N := depth A N;
	depthJ (inferC X J) N := nabla x, depthJ (J x) N;
	depthJ (inferAppC A X J) K := exists M N, nabla x,
		depth A M /\ depthJ (J x) N /\ add M N K.

Theorem depthJ_is_nat : forall J N, depthJ J N -> is_nat N.
induction on 1. intros. case H1.
	apply depth_is_nat to H3. apply add_is_nat_k to _ H4. search.
	backchain depth_is_nat.
	apply IH to H2. search.
	apply IH to H3. backchain add_is_nat_k.

Theorem depthJ_total_wfjg : forall E J, wfjg E J -> exists N, depthJ J N.
induction on 1. intros. case H1.
	apply depth_wfta_total to H2. apply depth_wfta_total to H3.
		apply depth_is_nat to H4.
		apply add_total to H6 with n = N1. search.
	apply depth_wfta_total to H3. search.
	apply IH to H3. apply depthJ_is_nat to H4.
		apply nat_prune_ty to H5. search.
	apply IH to H4. apply depthJ_is_nat to H5. apply nat_prune_ty to H6.
		apply depth_wfta_total to H3. apply depth_is_nat to H7.
		apply add_total to H8 with n = Nr. search.

Define depthl : olist -> nat -> prop by
	depthl nil z;
	nabla x, depthl (exvar x :: E) (s N) := depthl E N;
	nabla x, depthl (tyvar x :: E) (s N) := depthl E N;
	nabla x, depthl (of x A :: E) (s N) := depthl E N;
	depthl (j J :: E) (s K) := exists M N, depthJ J M /\ depthl E N /\ add M N K.

Theorem depthl_prune : forall E N, nabla (x : ty),
	depthl (E x) (N x) -> exists Nr, N = x\ Nr.
induction on 1. intros. case H1.
	search.
	apply IH to H2. search.
	search.
	apply IH to H2. search.
	search.
	apply IH to H2. search.
	apply depthJ_is_nat to H2. apply nat_prune_ty to H5.
		apply IH to H3. apply add_prune_k[ty] to H4. search.

Theorem depthl_total : forall E, wfj E -> exists N, depthl E N.
induction on 1. intros. case H1. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. search.
	apply IH to H2. apply depthJ_total_wfjg to H3.
		apply depthJ_is_nat to H5.
		apply add_total to H6 with n = N. search.

Theorem depthl_is_nat : forall E N, depthl E N -> is_nat N.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.
	apply IH to H3. apply add_is_nat_k to _ H4. search.
Theorem depthl_total_nat : forall E, wfj E -> exists NE, depthl E NE /\ is_nat NE.
intros. apply depthl_total to H1. apply depthl_is_nat to H2. search.


Theorem subExp_tmSizel_z : forall Exp, subExp Exp -> tmSizel Exp z.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.
Theorem subExp_m_judge_z : forall Exp, subExp Exp -> m_judge Exp z.
induction on 1. intros. case H1. search.
	apply IH to H2. search. apply IH to H2. search. apply IH to H2. search.

Define fresh_ty : ty -> ty -> prop by
  nabla x, fresh_ty x A.

Theorem equivJ_decidable : forall E F,
	equivJ E F -> (judge F \/ (judge F -> false)) -> (judge E \/ (judge E -> false)).
intros. case H1. case H2. apply H4 to H5. search.
	right. intros. backchain H5. backchain H3.

Theorem fv_decidable : forall E A, nabla (x : ty), wfta (E x) (A x) ->
	(exists Ar, A = x\ Ar) \/ ((exists Ar, A = x\ Ar) -> false).
induction on 1. intros. case H1. search. search. search. search. search.
	apply IH to H2. apply IH to H3. case H4.
		case H5. search. right. intros. case H7. backchain H6.
		right. intros. case H7. backchain H6.
	apply IH to H2. case H3. search. right. intros. case H5. backchain H4.

Define all_ : ty -> prop by
	all_ (all A).

Theorem decidable_thm : forall E NT NJ NO NV ND, wfj E ->
	tmSizel E NT -> is_nat NT ->
	m_judge E NJ -> is_nat NJ ->
	orderl E NO -> is_nat NO ->
	nVar E NV -> is_nat NV ->
	depthl E ND -> is_nat ND ->
	judge E \/ (judge E -> false).
induction on 3. induction on 5. induction on 7. induction on 9. induction on 11.
intros W T IT J IJ O IO V IV D ID. W: case W. search.
	% E, a
	T: case T. J: case J. O: case O. V: case V. D: case D. ID: case ID.
		Jg: apply IH4 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, ^a
	T: case T. J: case J. O: case O. V: case V. D: case D.
		IV: case IV. ID: case ID.
		Jg: apply IH3 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, x:A
	T: case T. J: case J. O: case O. V: case V. D: case D. ID: case ID.
		Jg: apply IH4 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg.
		search. right. intros. case H1. backchain Jg.
	% E, J
	W: case W1.
	% E, A <: B
	T: case T. J: case J. V: case V. clear IH. clear IH1.
		Linst: assert name A -> member (exvar A) E1 -> fresh_ty A B ->
			judge (j (subty A B) :: E1) \/ (judge (j (subty A B) :: E1) -> false).
			intros A M B. case A. case B.
			Jg: apply instantiation_decidable_L to W2 _ _. Jg: case Jg. search.
			W: apply jExt_wfj to Jg _.
			T: case T. case T2. T: apply jExt_tmSizel to _ Jg _.
			case J. case J2. J: apply jExt_m_judge to _ Jg _.
			Jg: case Jg1.
				O: case O. O: case O. apply order_det to Jg1 *O3. case O. case O4. case O2.
					apply nVar_det to V *Jg2. IV: case IV.
					O: apply jExt_orderl to _ Jg _. D: apply depthl_total_nat to W3.
					Jg: apply IH3 to W3 _ IT _ IJ _ IO _ IV _ D2. backchain equivJ_decidable.
				O: case O. O: case O. apply order_det to Jg2 *O3. case O. case O4. P: case O2.
					IO: case IO. O: apply jExt_orderl to _ Jg _.
					O: apply orderl_append to _ _ Jg1 _.
					TI: apply subExp_tmSizel_z to Jg4. DI: apply subExp_m_judge_z to Jg4.
					T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
					V: apply nVar_total_nat to Jg5. D: apply depthl_total_nat to Jg5.
					Jg: apply IH2 to Jg5 _ IT _ IJ _ IO _ V2 _ D2. backchain equivJ_decidable.
		Rinst: assert name B -> member (exvar B) E1 -> fresh_ty B A ->
			judge (j (subty A B) :: E1) \/ (judge (j (subty A B) :: E1) -> false).
			intros A M B. case A. case B.
			Jg: apply instantiation_decidable_R to W1 _ _. Jg: case Jg. search.
			W: apply jExt_wfj to Jg _.
			T: case T. case T2. T: apply jExt_tmSizel to _ Jg _.
			case J. case J2. J: apply jExt_m_judge to _ Jg _.
			Jg: case Jg1.
				O: case O. O: case O. apply order_det to Jg1 *O. case O3. case O4. case O2.
					apply nVar_det to V *Jg2. IV: case IV.
					O: apply jExt_orderl to _ Jg _. D: apply depthl_total_nat to W3.
					Jg: apply IH3 to W3 _ IT _ IJ _ IO _ IV _ D2. backchain equivJ_decidable.
				O: case O. O: case O. case O3. apply order_det to Jg2 *O.
					P: apply add_z_eq to *O4. P: case O2.
					IO: case IO. O: apply jExt_orderl to _ Jg _.
					O: apply orderl_append to _ _ Jg1 _.
					TI: apply subExp_tmSizel_z to Jg4. DI: apply subExp_m_judge_z to Jg4.
					T: apply tmSizel_append to _ T Jg1 _. J: apply m_judge_append to _ J Jg1 _.
					V: apply nVar_total_nat to Jg5. D: apply depthl_total_nat to Jg5.
					Jg: apply IH2 to Jg5 _ IT _ IJ _ IO _ V2 _ D2. backchain equivJ_decidable.
		Lall: assert all_ A -> notAll_ B -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false). intros A NB. case A. clear IH3. clear IH4.
			O: case O. O: case O. O: case O. O: case O4. O: case O2. IO: case IO.
			W: apply wfta_open_exvar to _ W1. W: apply wfta_weaken_ex to W2.
			W: assert wfj (j (subty (A1 n1) B) :: exvar n1 :: E1).
			V: apply nVar_total_nat to W5. D: apply depthl_total_nat to W5.
			T: case T. case T2. J: case J. case J2.
			Jg: apply IH2 to W5 _ IT _ IJ _ IO _ V2 _ D2. Jg: case Jg. search.
			W: case W2.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				W: case W1. O: case O3. P: apply add_s_inv to O4.
				W: apply wfta_weaken_ty to _ with T = all A1.
				W: assert wfj (j (subty (all A1) (A2 n1)) :: tyvar n1 :: E1).
				V: apply nVar_total_nat to W7. D: apply depthl_total_nat to W7.
				Jg: apply IH2 to W7 _ IT _ IJ _ IO _ V4 _ D4. Jg: case Jg1. search.
					right. intros. case H1. backchain Jg. backchain Jg1.
		Rall: assert all_ B -> judge (j (subty A B) :: E1) \/
				(judge (j (subty A B) :: E1) -> false). intros A. case A. clear IH3. clear IH4.
			O: case O. O: case O. O: case O3. O: apply add_s_inv to *O4. O: case O2. IO: case IO.
			W: case W2. W: apply wfta_weaken_ty to W1.
			W: assert wfj (j (subty A (A1 n1)) :: tyvar n1 :: E1).
			V: apply nVar_total_nat to W4. D: apply depthl_total_nat to W4.
			T: case T. case T2. J: case J. case J2.
			Jg: apply IH2 to W4 _ IT _ IJ _ IO _ V2 _ D2. Jg: case Jg. search.
			W: case W1.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. backchain Jg.
				right. intros. case H1. case H2. backchain H4. backchain Jg.

		W: case W1.
			% A = 1
			clear Linst. W: case W2 (keep).
				% B = 1.
				O: case O. O: case O. case O. case O3. case O4. case O2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: apply IH4 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg. search.
						right. intros. case H1. backchain Jg.
				% B = a
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = ^a
				backchain Rinst.
				% B = A1 -> B1
				right. intros. case H1.
				% B = \forall x. A1
				backchain Rall.
			% A = a
			clear Linst. W: case W2 (keep).
				% B = 1
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = b
				right. intros. case H1.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _ with X = n2. backchain split3_mem.
					case H2. apply wfj_tyvar_exvar to W _ _. backchain split3_mem.
				% B = a
				O: case O. O: case O. case O. case O3. case O4. case O2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: apply IH4 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg. search.
						right. intros. case H1. backchain Jg. apply wfj_tyvar_exvar to W _ _.
				% B = ^b
				backchain Rinst.
				% B = ^a
				apply wfj_tyvar_exvar to W _ _.
				% B = A1 -> B1
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = \forall x. A1
				backchain Rall.
			% A = ^a
			W: case W2 (keep).
				% B = 1 or b
				backchain Linst. backchain Linst.
				% B = a
				apply wfj_tyvar_exvar to W _ _.
				% B = ^b
				backchain Linst.
				% B = ^a
				O: case O. O: case O. case O. case O3. case O4. case O2.
					D: case D. D: case D. case D. case D3. case D4. case D2. ID: case ID.
					J: case J. case J2. T: case T. case T2.
					Jg: apply IH4 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg.
					search. right. intros. case H1. apply wfj_tyvar_exvar to W _ _. backchain Jg.
				% B = A1 -> B1
				Fv: apply fv_decidable to W2. Fv: case Fv. backchain Linst.
					right. intros Jg. case Jg. backchain Fv.
				% B = \forall x. A1
				O: case O. O: case O. case O. O: case O3. case O4. O: case O2. IO: case IO.
					W: case W2. W: assert wfj (j (subty n1 (A1 n1 n2)) :: tyvar n2 :: E1 n1).
					V: apply nVar_total to W4. IV: apply nVar_is_nat to V1.
					D: apply depthl_total to W4. ID: apply depthl_is_nat to D1.
					J: case J. case J2. T: case T. case T2.
					Jg: apply IH2 to W4 _ IT _ IJ _ IO _ IV1 _ ID1. Jg: case Jg.
						search. right. intros. case H1. backchain Jg.
			% A = A1 -> B1
			W: case W2 (keep).
				% B = 1
				right. intros. case H1.
				% B = a
				right. intros. case H1. case H2.
					apply wfj_tyvar_exvar to W _ _. backchain append_mem.
				% B = ^a
				Fv: apply fv_decidable to _ with A = x\ arrow (A1 x) (B1 x).
					Fv: case Fv. backchain Rinst.
					right. intros Jg. case Jg. backchain Fv.
				% B = A2 -> B2
				O: case O. O: case O. O: case O. O: case O3. P: apply add_assoc4 to O6 O8 _.
					D: case D. D: case D. D: case D. D: case D3. P: case D4.
					P: apply add_s_inv to *P3. P: case D2. P: case P4.
					P: apply add_assoc4 to D6 D8 _. ID: case ID.
					W: assert wfj (j (subty A2 A1) :: j (subty B1 B2) :: E1).
						apply wfta_weaken_j to W4 with J = subty B1 B2.
						apply wfta_weaken_j to W1 with J = subty B1 B2. search.
					J: case J. case J2. T: case T. case T2.
					Jg: apply IH4 to W6 _ IT _ IJ _ IO _ IV _ ID.
						P: apply add_s to P7. P: apply add_assoc to P7 P4.
						P: apply add_s to P10. search.
						O: apply add_assoc to P2 O2. search.
					Jg: case Jg. search. right. intros. case H1. backchain Jg.
				% B = \forall x. A
				backchain Rall.
			% A = \forall x. A1
			W: case W2.
				backchain Lall.
				backchain Lall.
				backchain Lall.
				backchain Lall.
				backchain Rall.
	% E, e <= A
	T: case T. T: case T. J: case J. J: case J. P: case J2. P: case P. P: case P.
		O: case O. O: case O. V: case V.
		chkSub: assert notAll_ A -> notLam_ X -> judge (j (check X A) :: E1) \/
			(judge (j (check X A) :: E1) -> false).
			W: apply wfta_weaken_ty to W2. % ^a for now
			W: assert wfj (j (inferC X (a\subty a A)) :: E1).
			IJ: case IJ. D: apply depthl_total to W4. ID: apply depthl_is_nat to D1.
			N: apply tmSize_is_nat to T. P: apply add_zero to N.
			Jg: apply IH1 to W4 _ IT _ IJ _ IO _ IV _ ID1. Jg: case Jg. search.
				intros. right. intros. case H3.
					F: case H1. apply F to _.
					F: case H2. apply F to _.
					F: case H2. apply F to _. backchain Jg.
		W: case W2.
			% A = i
			W: case W1.
				case T. T: case T2. case T. case O. case O2.
					D: case D. D: case D. case D. case D2. ID: case ID.
					IJ: case IJ. IJ: case IJ. IT: case IT.
					Jg: apply IH1 to W _ IT _ IJ _ IO _ IV _ ID. Jg: case Jg. search.
						right. intros Jg. Jg: case Jg1. Jg: case Jg3. Jg: case Jg3. backchain Jg.
				backchain chkSub.
				right. intros. case H1. F: case H3. apply F to _.
				backchain chkSub. backchain chkSub.
			% A = a
			W: case W1.
				backchain chkSub. backchain chkSub.
				right. intros. case H1. case H2.
					apply append_mem to H4 _. apply wfj_tyvar_exvar to W _ _.
					F: case H3. apply F to _.
				backchain chkSub. backchain chkSub.
			% A = ^a
			W: case W1 (keep).
				backchain chkSub. backchain chkSub.
				clear W3. clear W4. T: case T. T: case T2. IT: case IT.
					A: apply single_append to W2. apply wfj_prune_exvar to _ A.
					W: apply wfj_insert_exvar_intro to A _.
					W: apply wftm_insert_exvar to A _ _ W1.
					W: assert wfj (j (check (X1 (arrow n1 n2) n3) n2) :: of n3 n1 :: FxyE n1 n2).
						W: apply wftm_anyA to W5 with A = n1.
						M: apply append_mem to W3 _. M: apply append_mem to W3 _ with X = exvar n1.
						search.
					Ext: apply jExt_inst to _ W3 _ with F = A2.
					T: apply tmSizel_total_wfj to W4. apply jExt_tmSizel_eq to _ Ext _ _.
					apply tmSize_prune to T.
					T: apply tmSize_subst to T with X = x\ X1 x n2, A = x\ arrow x n2, x = n1.
					T: assert tmSizel
						(j (check (X1 (arrow n1 n2) n3) n2) :: of n3 n1 :: FxyE n1 n2) (K2 n1).
					J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J.
					O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O3.
					V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
					D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
					Jg: apply IH to W6 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
						right. intros. case H1. apply inst_det to H2 _ _ with G = FxyE. backchain Jg.
						F: case H3. apply F to _.
				backchain chkSub. backchain chkSub.
			% A = A1 -> B
			W: case W1 (keep).
				backchain chkSub. backchain chkSub.
				W: assert wfj (j (check (X1 n1) B) :: of n1 A1 :: E1).
					W: apply wftm_anyA to W1 with A = A1. W: apply wfta_weaken_of to W3 with A = A1.
					search.
					T: case T. T: case T2. IT: case IT.
					J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J.
					O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O3.
					V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
					D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
					Jg: apply IH to W6 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
						right. intros. case H1. backchain Jg.
						F: case H3. apply F to _.
				backchain chkSub. backchain chkSub.
			% A = \forall x. A
			O: case O. O: case O2. IO: case IO.
				W: apply wftm_weaken_ty to W1.
				W: assert wfj (j (check X (A1 n1)) :: tyvar n1 :: E1).
				V: apply nVar_total to W4. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W4. ID: apply depthl_is_nat to D1.
				Jg: apply IH2 to W4 _ IT _ IJ _ IO _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
					F: case H2. apply F to _.
	% E, e => w
	clear IH3. clear IH4. W: case W1.
		% () => 1
		W: apply wfjg_subst_tyvar to W2 _ _.
			T: case T. T: case T. T: case T. T: case T4. case T. T: case T2. IT: case IT.
			T: apply tmSizeJ_total to W1. T: apply tmSizeJ_subst_eq to T3 T2.
			W: assert wfj (j (J1 i) :: E1).
				J: apply m_judge_total_wfj to W3. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W3. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W3. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W3. ID: apply depthl_is_nat to D1.
				Jg: apply IH to W3 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% x => A
		W: apply wfj_of_wfta to _ W1.
			T: case T. apply nat_prune_tm to IT. apply add_prune[tm] to T2. T: case T.
			case T. T: case T4. case T. T: case T2. IT: case IT.
			W: apply wfjg_subst_tyvar to W2 _ _.
			T: apply tmSizeJ_total to W4. apply tmSizeJ_subst_eq to T3 T2.
			W: assert wfj (j (J1 n2 A) :: E1 n2).
				J: apply m_judge_total_wfj to W5. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W5. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W5. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W5. ID: apply depthl_is_nat to D1.
				Jg: apply IH to W5 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. apply wfj_of_det to _ W1 H2. backchain Jg.
		% \lambda x. X => ^a -> ^b
		W: apply wfjg_ty2ex to W2 _.
			W: apply wfjg_insert_exvar to _ _ _ W4 with E = E1, F = x\ nil.
			W: assert wfj (j (J1 (arrow n2 n3)) :: exvar n3 :: exvar n2 :: E1).
			W: apply wftm_weaken_f to _ _ with F = E1, T = lam X1,
				EF = j (J1 (arrow n2 n3)) :: exvar n3 :: exvar n2 :: E1.
			W: apply wftm_anyA to *W7 with A = n2.
			W: assert 6 wfj (j (check (X1 n1) n3) :: of n1 n2 :: j (J1 (arrow n2 n3)) ::
				exvar n3 :: exvar n2 :: E1).
			T: case T. T: case T. T: case T. P: case T4. P: case T2. IT: case IT.
			T: assert tmSizel (j (check (X1 n1) n3) :: of n1 n2 :: j (J1 (arrow n2 n3)) ::
					exvar n3 :: exvar n2 :: E1) K1.
				T: apply tmSizeJ_total to W5. permute (n1 n2) T2. apply tmSizeJ_subst_eq to T3 T2.
				P: apply add_assoc to P P1. search.
			J: apply m_judge_total_wfj to W8. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W8. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W8. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W8. ID: apply depthl_is_nat to D1.
				Jg: apply IH to W8 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% X1 X2 => ...
		T: case T. T: case T. T: case T. P: case T4. P: case T2. IT: case IT.
			W: apply wftm_weaken_ty to W3.
			W: apply wfjg_weaken_tyvar_fresh to _ _ _ W2 with FxE = x\ tyvar n1 :: tyvar x :: E1.
			W: assert wfj (j (inferC X1 (a\ inferAppC a Y J1)) :: E1).
			P: apply add_assoc to T6 P.
			T: assert tmSizel (j (inferC X1 (a\ inferAppC a Y J1)) :: E1) K2.
				J: apply m_judge_total_wfj to W6. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W6. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W6. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W6. ID: apply depthl_is_nat to D1.
				Jg: apply IH to W6 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% (X : A) => A
		T: case T. T: case T. T: case T. P: case T4. P: case T2. IT: case IT.
			W: apply wfjg_subst_tyvar to W2 _ _.
			T: apply tmSizeJ_total to W4. apply tmSizeJ_subst_eq to T3 T2.
			P: apply add_assoc to P P1.
			W: apply wftm_weaken_j to W1 with J = J1 A.
			W: apply wfta_weaken_j to W3 with J = J1 A.
			W: assert wfj (j (check X1 A) :: j (J1 A) :: E1).
				J: apply m_judge_total_wfj to W7. IJ: apply m_judge_is_nat to J1.
				O: apply orderl_total_wfj to W7. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W7. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W7. ID: apply depthl_is_nat to D1.
				Jg: apply IH to W7 _ IT _ IJ1 _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
	% E, A ` e =>> w
	clear IH3. clear IH4. W: case W2.
		right. intros. case H1.
		right. intros. case H1. case H2. apply append_mem to H4 _.
			apply wfj_tyvar_exvar to W _ _.
		% A = ^a
		A: apply single_append to W2. apply wfj_prune_exvar to _ A.
			A: apply wfj_insert_exvar_intro to A _.
			W: apply wfjg_insert_exvar to _ _ _ W3 with F = x\ tyvar n1 :: A1 x.
			W: apply wftm_insert_exvar to _ _ _ W1 with F = A1.
			M: apply append_mem to A1 _. M: apply append_mem to A1 _ with X = exvar n1.
			W: apply wftm_weaken_j to W5 with J = J1 (arrow n2 n3) n3.
			W: apply wfjg_subst_tyvar to W4 _ _ with A = n4.
			Ext: apply jExt_inst to _ _ _ with F = A1.
			apply nat_prune_ty to IT.
			T: assert tmSizel (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2) Nr.
				T: case T. apply add_prune[ty] to T2.
				T: apply jExt_tmSizel to _ Ext _.
				T: case T. apply add_prune[ty] to T5.
				T: apply tmSizeJ_total to W7.
				N: apply tmSizeJ_is_nat to T6. apply nat_prune_ty to N. apply nat_prune_ty to *N.
				apply tmSizeJ_subst_eq to T4 _ with A = x\ arrow x n1.
				P: apply add_assoc to T5 T2.
				T: apply tmSize_subst to T with A = arrow n1.
				search.
			apply nat_prune_ty to IJ. J: case J. J: case J. J: case J2. IJ: case IJ.
			J: assert m_judge (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2) Nr2.
				P: case J2. P: case P. apply add_prune[ty] to P.
				J: apply jExt_m_judge to _ Ext _.
				J: apply m_judgeJ_total_wfjg to W7.
				N: apply m_judgeJ_is_nat to J3. apply nat_prune_ty to N. apply nat_prune_ty to *N.
				apply m_judgeJ_subst_eq to J _ with A = x\ arrow x n1.
				search.
			W: assert wfj (j (check (X (arrow n1 n2)) n1) ::
					j (J1 (arrow n1 n2) n2) :: FxyE n1 n2).
				O: apply orderl_total_wfj to W8. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W8. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W8. ID: apply depthl_is_nat to D1.
				Jg: apply IH1 to W8 _ IT _ IJ _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. case H3.
					assert instJs E1 FxyE. apply inst_det to H2 *H5 _. backchain Jg.
		% A = A1 -> B
			T: case T. T: case T. P: apply add_assoc to T4 T2.
			J: case J. J: case J. P: case J2. P: case P2. P: case P2. IJ: case IJ.
			W: apply wftm_weaken_j to _ with J = J1 B. W: apply wfta_weaken_j to W2 with J = J1 B.
			W: apply wfjg_subst_tyvar to W3 W4 _.
			T: apply tmSizeJ_total to W7. apply tmSizeJ_subst_eq to T3 T5.
			J: apply m_judgeJ_total_wfjg to W7. apply m_judgeJ_subst_eq to J J2.
			W: assert wfj (j (check X A1) :: j (J1 B) :: E1).
				O: apply orderl_total_wfj to W8. IO: apply orderl_is_nat to O1.
				V: apply nVar_total to W8. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W8. ID: apply depthl_is_nat to D1.
				Jg: apply IH1 to W8 _ IT _ IJ _ IO1 _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.
		% A = \forall x. A
			T: case T. T: case T.
			J: case J. J: case J. P: case J2. P: case P. P: case P.
			O: case O. O: case O. O: case O.
				P: case O4. P: case O2. apply add_prune[ty] to P1. IO: case IO.
			T: assert tmSizel (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) NT.
			J: assert m_judge (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) (s (s (s K2))).
			O: assert orderl (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1) K4.
			W: assert wfj (j (inferAppC (A1 n1) X J1) :: exvar n1 :: E1).
				W: apply wftm_weaken_ex to _.
				W: apply wfta_open_exvar to _ _.
				W: apply wfjg_insert_exvar_raw to _ _ _ W3 with FxE = x\ tyvar n1 :: exvar x :: E1.
				search.
				V: apply nVar_total to W4. IV: apply nVar_is_nat to V1.
				D: apply depthl_total to W4. ID: apply depthl_is_nat to D1.
				Jg: apply IH2 to W4 _ IT _ IJ _ IO _ IV1 _ ID1. Jg: case Jg. search.
					right. intros. case H1. backchain Jg.


Theorem decidable : forall E, wfj E -> judge E \/ (judge E -> false).
intros W.
	T: apply tmSizel_total_wfj to W. IJ: apply tmSizel_is_nat to T.
	J: apply m_judge_total_wfj to W. IJ: apply m_judge_is_nat to J.
	O: apply orderl_total_wfj to W. IO: apply orderl_is_nat to O.
	V: apply nVar_total to W. IV: apply nVar_is_nat to V.
	D: apply depthl_total to W. ID: apply depthl_is_nat to D.
	backchain decidable_thm.

Theorem decidable_decl : forall E, wfj E -> exFree E -> dc E \/ (dc E -> false).
intros.
	Jg: apply decidable to H1. Jg: case Jg.
	left. apply soundness to _ _. T: case H3. search.
		apply append_mem to T _. apply exFree_false to H5 _.
	right. intros D. T: assert tex E E.
		E: apply tex_exFree to T _.
		apply dcl_complete to H1 _ _.
		apply completeness to _ _ _.
		backchain Jg.

